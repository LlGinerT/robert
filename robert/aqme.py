"""
Parameters
----------

General
+++++++

     csv_name : str, default=''
         Name of the CSV file containing the database with SMILES and code_name columns. A path can be provided (i.e. 'C:/Users/FOLDER/FILE.csv'). 
     destination : str, default=None,
         Directory to create the output file(s).
     varfile : str, default=None
         Option to parse the variables using a yaml file (specify the filename, i.e. varfile=FILE.yaml).  
     qdescp_atom : str, default=None
         Atomic properties will have
     ewin_csearch : float, default=0.1
         Energy window in kcal/mol to discard conformers (i.e. if a conformer is 
         more than te E window compared to the most stable conformer).
     dbstep_r : float, default=3.5
         Radius used in the DBSTEP calculations (in A).
"""
#####################################################.
#         This file stores the AQME class           #
#     used to perform the AQME-ROBERT workflow      #
#####################################################.

import subprocess
import time
import sys
from robert.utils import (load_variables,
    finish_print)

class aqme:
    """
    Class containing all the functions from the AQME module.

    Parameters
    ----------
    kwargs : argument class
        Specify any arguments from the AQME module (for a complete list of variables, visit the ROBERT documentation)
    """

    def __init__(self, **kwargs):

        # check if AQME is installed (required for this module)
        try:
            from aqme.qprep import qprep
        except ModuleNotFoundError:
            print("x  AQME is not installed (required for the --aqme option)! You can install the program with 'conda install -c conda-forge aqme'")
            sys.exit()

        start_time = time.time()

        # load default and user-specified variables
        self.args = load_variables(kwargs, "aqme")

        # run the initial AQME-CSEARCH conformational search with RDKit
        subprocess.run(['python', '-m', 'aqme', '--csearch', '--program', 'rdkit', '--input', self.args.csv_name, '--ewin_csearch', self.args.ewin_csearch])

        # run QDESCP to generate descriptors
        cmd_qdescp = ['python', '-m', 'aqme', '--qdescp', '--files', 'CSEARCH/*.sdf', '--program', 'xtb', '--csv_name', self.args.csv_name]
        if self.args.qdescp_atom is not None:
            cmd_qdescp.append('--qdescp_atom')
            cmd_qdescp.append(self.args.qdescp_atom)
        if self.args.dbstep_r != 3.5:
            cmd_qdescp.append('--dbstep_r')
            cmd_qdescp.append(self.args.dbstep_r)
        subprocess.run(cmd_qdescp)

        # # if no qdesc_atom is set, only keep molecular properties and discard atomic properties
        # si qdescp_atom es None, quite las prop moleculares (en plan por 
        # cada columna, si tiene ] descarta), y reemplaza el CSV viejo con listas

        # # ensure that the AQME database was successfully created
        # mira que alfinal que el CSV del database se haya creado

        # # move AQME output files
        # mueve todo lo que AQME genera a una carpeta que ponga AQME, incluido base de datos

        # if no qdescp_atom was selected, remove atomic descriptors generated by QDESCP
        _ = finish_print(self,start_time,'AQME')
